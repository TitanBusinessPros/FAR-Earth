<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FAR-Earth: Chronicles of the Neon Warriors</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Rajdhani', sans-serif;
            overflow: auto;
            background: #000;
            cursor: crosshair;
        }
        
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-image: url('https://github.com/TitanBusinessPros/FAR-Earth/raw/main/Start%20Page.png');
            background-size: cover;
            background-position: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            z-index: 1000;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 20px;
        }
        
        .title {
            font-family: 'Orbitron', sans-serif;
            font-size: 5rem;
            font-weight: 900;
            color: #00ffff;
            text-shadow: 
                0 0 10px #00ffff,
                0 0 20px #00ffff,
                0 0 40px #00ffff,
                0 0 80px #00ffff;
            margin-bottom: 3rem;
            margin-top: 8rem;
            letter-spacing: 0.3rem;
            animation: titlePulse 3s ease-in-out infinite;
        }
        
        @media (max-width: 768px) {
            .title {
                font-size: 2.5rem;
                margin-top: 1rem;
                margin-bottom: 0.5rem;
            }
            
            .subtitle {
                font-size: 0.9rem;
                margin-bottom: 0.5rem;
            }
            
            .characterSelect {
                flex-direction: column;
                gap: 1rem;
                width: 100%;
                align-items: center;
            }
            
            .characterCard {
                width: 90vw;
                max-width: 280px;
            }
            
            .characterCard img {
                height: 150px;
            }
        }
        
        @keyframes titlePulse {
            0%, 100% { 
                text-shadow: 
                    0 0 10px #00ffff,
                    0 0 20px #00ffff,
                    0 0 40px #00ffff,
                    0 0 80px #00ffff;
            }
            50% { 
                text-shadow: 
                    0 0 20px #00ffff,
                    0 0 40px #00ffff,
                    0 0 80px #00ffff,
                    0 0 120px #00ffff;
            }
        }
        
        .subtitle {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.5rem;
            color: #fff;
            margin-bottom: 4rem;
            letter-spacing: 0.5rem;
            opacity: 0.8;
        }
        
        .characterSelect {
            display: flex;
            gap: 3rem;
            margin-bottom: 2rem;
        }
        
        .characterCard {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 1.5rem;
            width: 250px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .characterCard::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(0, 255, 255, 0.1), transparent);
            transform: rotate(45deg);
            transition: all 0.6s;
        }
        
        .characterCard:hover::before {
            left: 100%;
        }
        
        .characterCard:hover {
            transform: translateY(-10px) scale(1.05);
            border-color: #ff00ff;
            box-shadow: 
                0 0 20px #00ffff,
                0 0 40px #00ffff,
                inset 0 0 20px rgba(0, 255, 255, 0.2);
        }
        
        .characterCard img {
            width: 100%;
            height: 200px;
            object-fit: contain;
            margin-bottom: 1rem;
            filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.5));
        }
        
        .characterCard h3 {
            font-family: 'Orbitron', sans-serif;
            color: #00ffff;
            text-align: center;
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }
        
        .characterStats {
            color: #fff;
            font-size: 0.9rem;
            text-align: center;
            opacity: 0.8;
        }
        
        #gameCanvas {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            background: #000;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }
        
        #hud {
            display: none;
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            font-family: 'Orbitron', sans-serif;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }
        
        .hudItem {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            padding: 10px 20px;
            margin-bottom: 10px;
            border-radius: 5px;
            font-size: 1.2rem;
        }
        
        .healthBar {
            width: 200px;
            height: 30px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
        }
        
        .healthFill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6600);
            box-shadow: 0 0 20px #ff0000;
            transition: width 0.3s ease;
        }
        
        .healthText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 5px #000;
        }
        
        #controls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            padding: 15px 30px;
            border-radius: 10px;
            color: #00ffff;
            font-family: 'Rajdhani', sans-serif;
            text-align: center;
        }
        
        .hidden {
            display: none !important;
        }
        
        #levelComplete {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #00ff00;
            padding: 3rem;
            border-radius: 20px;
            text-align: center;
            box-shadow: 
                0 0 40px #00ff00,
                inset 0 0 40px rgba(0, 255, 0, 0.2);
        }
        
        #levelComplete h2 {
            font-family: 'Orbitron', sans-serif;
            color: #00ff00;
            font-size: 3rem;
            margin-bottom: 1rem;
            text-shadow: 0 0 20px #00ff00;
        }
        
        #levelComplete button {
            margin-top: 2rem;
            padding: 15px 40px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            background: #00ff00;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            color: #000;
            font-weight: bold;
        }
        
        #levelComplete button:hover {
            background: #00ffff;
            box-shadow: 0 0 20px #00ffff;
            transform: scale(1.1);
        }
        
        #pauseBtn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 150;
            background: rgba(0, 255, 255, 0.8);
            border: 2px solid #00ffff;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            color: #000;
            font-weight: bold;
            display: none;
        }
        
        #pauseBtn:hover {
            background: #00ffff;
            box-shadow: 0 0 20px #00ffff;
        }
        
        #pauseMenu {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #00ffff;
            padding: 3rem;
            border-radius: 20px;
            text-align: center;
        }
        
        #pauseMenu h2 {
            font-family: 'Orbitron', sans-serif;
            color: #00ffff;
            font-size: 2.5rem;
            margin-bottom: 2rem;
            text-shadow: 0 0 20px #00ffff;
        }
        
        #pauseMenu button {
            margin: 10px;
            padding: 15px 40px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            background: #00ffff;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            color: #000;
            font-weight: bold;
        }
        
        #pauseMenu button:hover {
            background: #00ff00;
            box-shadow: 0 0 20px #00ffff;
        }
        
        #gameOver {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #ff0000;
            padding: 3rem;
            border-radius: 20px;
            text-align: center;
            box-shadow: 
                0 0 40px #ff0000,
                inset 0 0 40px rgba(255, 0, 0, 0.2);
        }
        
        #gameOver h2 {
            font-family: 'Orbitron', sans-serif;
            color: #ff0000;
            font-size: 3rem;
            margin-bottom: 1rem;
            text-shadow: 0 0 20px #ff0000;
        }
        
        #gameOver button {
            margin-top: 2rem;
            padding: 15px 40px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            background: #ff0000;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            color: #fff;
            font-weight: bold;
        }
        
        #gameOver button:hover {
            background: #ff6600;
            box-shadow: 0 0 20px #ff6600;
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1 class="title">FAR-EARTH</h1>
        <p class="subtitle">CHOOSE YOUR WARRIOR</p>
        <div class="characterSelect">
            <div class="characterCard" data-character="0">
                <img src="https://github.com/TitanBusinessPros/FAR-Earth/raw/main/P-1.png" alt="Ember Knight">
                <h3>The Ember Knight</h3>
                <div class="characterStats">
                    <div>HP: 100</div>
                    <div>Weapon: Red Neon Orbs</div>
                    <div>Type: Ranged (500 range)</div>
                </div>
            </div>
            <div class="characterCard" data-character="1">
                <img src="https://github.com/TitanBusinessPros/FAR-Earth/raw/main/P-2.png" alt="Verdant Bulwark">
                <h3>The Verdant Bulwark</h3>
                <div class="characterStats">
                    <div>HP: 100</div>
                    <div>Weapon: Green Neon Orbs</div>
                    <div>Type: Ranged (500 range)</div>
                </div>
            </div>
            <div class="characterCard" data-character="2">
                <img src="https://github.com/TitanBusinessPros/FAR-Earth/raw/main/P-3.png" alt="Skybound Enchantress">
                <h3>Skybound Enchantress</h3>
                <div class="characterStats">
                    <div>HP: 100</div>
                    <div>Weapon: Blue Neon Orbs</div>
                    <div>Type: Ranged (500 range)</div>
                </div>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="hud">
        <div class="hudItem">Level: <span id="levelDisplay">1</span></div>
        <div class="hudItem">Lives: <span id="livesDisplay">3</span></div>
        <div class="hudItem">
            <div class="healthBar">
                <div class="healthFill" id="healthFill" style="width: 100%;"></div>
                <div class="healthText" id="healthText">100 / 100</div>
            </div>
        </div>
        <div class="hudItem">Enemies: <span id="enemyCount">75</span></div>
        <div class="hudItem">Zoom: <span id="zoomLevel">50</span>%</div>
    </div>

    <div id="controls">
        WASD/Arrows: Move | Mouse: Aim | Click/Space: Attack | Scroll: Zoom
    </div>

    <div id="mobileControls" style="display: none; position: fixed; bottom: 20px; width: 100%; z-index: 100;">
        <div style="display: flex; justify-content: space-between; padding: 0 20px;">
            <div id="joystickContainer" style="position: relative; width: 150px; height: 150px;">
                <div id="joystickBase" style="position: absolute; width: 150px; height: 150px; background: rgba(0,255,255,0.3); border: 3px solid #00ffff; border-radius: 50%;"></div>
                <div id="joystickStick" style="position: absolute; width: 60px; height: 60px; background: rgba(0,255,255,0.8); border: 2px solid #00ffff; border-radius: 50%; left: 45px; top: 45px;"></div>
            </div>
            <div id="fireBtn" style="width: 100px; height: 100px; background: rgba(255,0,0,0.6); border: 3px solid #ff0000; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: #fff; font-family: 'Orbitron', sans-serif; font-size: 1.5rem; font-weight: bold;">FIRE</div>
        </div>
    </div>

    <div id="levelComplete">
        <h2>LEVEL COMPLETE!</h2>
        <p style="color: #00ff00; font-size: 1.5rem;">All enemies eliminated</p>
        <button id="nextLevelBtn">Continue to Next Level</button>
    </div>

    <button id="pauseBtn">‚è∏ PAUSE</button>

    <div id="pauseMenu">
        <h2>PAUSED</h2>
        <button id="resumeBtn">Resume</button>
        <button id="quitBtn">Quit to Menu</button>
    </div>

    <div id="gameOver">
        <h2>MISSION FAILED</h2>
        <p style="color: #ff0000; font-size: 1.5rem;">You have been defeated</p>
        <button id="restartBtn">Restart Game</button>
    </div>

    <audio id="bgMusic" loop>
        <source src="https://github.com/TitanBusinessPros/FAR-Earth/raw/main/B-Song-1.mp3" type="audio/mpeg">
    </audio>

    <script>
        // Sound system
        const sounds = {
            playerAttack: {
                0: new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVDghQoe3rstlaFAE7j9/zuWcbCjiK0+3Pf08AAAA='), // Red laser
                1: new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVDghQoe3rstlaFAE7j9/zuWcbCjiK0+3Pf08AAAA='), // Green laser
                2: new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVDghQoe3rstlaFAE7j9/zuWcbCjiK0+3Pf08AAAA=')  // Blue laser
            },
            enemyHit: new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVDghQoe3rstlaFAE7j9/zuWcbCjiK0+3Pf08AAAA='),
            enemyAttack: new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVDghQoe3rstlaFAE7j9/zuWcbCjiK0+3Pf08AAAA='),
            playerHit: new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVDghQoe3rstlaFAE7j9/zuWcbCjiK0+3Pf08AAAA=')
        };

        function playSound(type, index) {
            try {
                let audio;
                if (type === 'playerAttack') {
                    audio = sounds.playerAttack[index].cloneNode();
                } else {
                    audio = sounds[type].cloneNode();
                }
                audio.volume = 0.3;
                audio.play().catch(function(e) {
                    console.log('Sound play failed:', e);
                });
            } catch(e) {
                console.log('Sound error:', e);
            }
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let gameState = {
            currentLevel: 1,
            selectedCharacter: null,
            player: null,
            enemies: [],
            projectiles: [],
            gasClouds: [],
            camera: { x: 0, y: 0, zoom: 0.5 },
            keys: {},
            mouse: { x: 0, y: 0, down: false },
            mapSize: { width: 10000, height: 6000 },
            images: {},
            gameStarted: false,
            saveData: null,
            targetEnemy: null,
            lives: 3
        };

        const characters = [
            {
                name: 'The Ember Knight of Far-Earth',
                image: 'https://github.com/TitanBusinessPros/FAR-Earth/raw/main/P-1.png',
                hp: 100,
                maxHp: 100,
                speed: 3.75,
                attackRange: 500,
                attackDamage: 10,
                attackColor: '#ff0000',
                attackType: 'ranged',
                attackCooldown: 500,
                lastAttack: 0
            },
            {
                name: 'The Verdant Bulwark of Far-Earth',
                image: 'https://github.com/TitanBusinessPros/FAR-Earth/raw/main/P-2.png',
                hp: 100,
                maxHp: 100,
                speed: 3.125,
                attackRange: 500,
                attackDamage: 15,
                attackColor: '#00ff00',
                attackType: 'ranged',
                attackCooldown: 700,
                lastAttack: 0
            },
            {
                name: 'Skybound Enchantress of Far-Earth',
                image: 'https://github.com/TitanBusinessPros/FAR-Earth/raw/main/P-3.png',
                hp: 100,
                maxHp: 100,
                speed: 4.375,
                attackRange: 500,
                attackDamage: 8,
                attackColor: '#0088ff',
                attackType: 'ranged',
                attackCooldown: 400,
                lastAttack: 0
            }
        ];

        const enemyTypes = {
            clawWorm: {
                image: 'https://github.com/TitanBusinessPros/FAR-Earth/raw/main/Claw-Worm-1.png',
                hp: 15,
                maxHp: 15,
                speed: 0,
                attackRange: 500,
                pullStrength: 0.5,
                damagePerSecond: 1,
                sightRange: 500,
                type: 'clawWorm'
            },
            neonWorm: {
                image: 'https://github.com/TitanBusinessPros/FAR-Earth/raw/main/Neon-Worm-1.png',
                hp: 15,
                maxHp: 15,
                speed: 0,
                attackRange: 500,
                attackDamage: 1,
                sightRange: 500,
                shootCooldown: 2000,
                lastShot: 0,
                type: 'neonWorm'
            },
            gasWorm: {
                image: 'https://github.com/TitanBusinessPros/FAR-Earth/raw/main/Gas-Worm-1.png',
                hp: 30,
                maxHp: 30,
                speed: 1.5,
                attackRange: 500,
                attackDamage: 2,
                sightRange: 500,
                shootCooldown: 3000,
                lastShot: 0,
                type: 'gasWorm'
            }
        };

        function preloadImages() {
            const imageUrls = [
                'https://github.com/TitanBusinessPros/FAR-Earth/raw/main/BG-Tile.png',
                'https://github.com/TitanBusinessPros/FAR-Earth/raw/main/P-1.png',
                'https://github.com/TitanBusinessPros/FAR-Earth/raw/main/P-2.png',
                'https://github.com/TitanBusinessPros/FAR-Earth/raw/main/P-3.png',
                'https://github.com/TitanBusinessPros/FAR-Earth/raw/main/Claw-Worm-1.png',
                'https://github.com/TitanBusinessPros/FAR-Earth/raw/main/Neon-Worm-1.png',
                'https://github.com/TitanBusinessPros/FAR-Earth/raw/main/Gas-Worm-1.png'
            ];

            imageUrls.forEach(function(url) {
                const img = new Image();
                img.onload = function() {
                    gameState.images[url] = img;
                };
                img.src = url;
            });
        }

        function selectCharacter(index) {
            gameState.selectedCharacter = index;
            loadGame();
            startGame();
        }

        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameCanvas').style.display = 'block';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('controls').style.display = 'block';
            document.getElementById('pauseBtn').style.display = 'block';
            
            initializeLevel();
            gameState.gameStarted = true;
            gameLoop();
        }

        function initializeLevel() {
            const charTemplate = characters[gameState.selectedCharacter];
            gameState.player = {
                x: gameState.mapSize.width / 2,
                y: gameState.mapSize.height / 2,
                width: 432,
                height: 576,
                angle: 0,
                hp: charTemplate.maxHp,
                maxHp: charTemplate.maxHp,
                speed: charTemplate.speed,
                attackRange: charTemplate.attackRange,
                attackDamage: charTemplate.attackDamage,
                attackColor: charTemplate.attackColor,
                attackType: charTemplate.attackType,
                attackCooldown: charTemplate.attackCooldown,
                lastAttack: 0,
                image: charTemplate.image,
                isAttacking: false,
                attackAngle: 0,
                latched: false
            };

            gameState.camera.x = gameState.player.x - canvas.width / 2;
            gameState.camera.y = gameState.player.y - canvas.height / 2;

            gameState.enemies = [];
            gameState.projectiles = [];
            gameState.gasClouds = [];

            for (let i = 0; i < 20; i++) {
                createEnemy('clawWorm');
            }

            for (let i = 0; i < 25; i++) {
                createEnemy('neonWorm');
            }
            
            for (let i = 0; i < 30; i++) {
                createEnemy('gasWorm');
            }

            updateEnemyCount();
            updateHealth();
        }

        function createEnemy(type) {
            const template = enemyTypes[type];
            const enemy = {
                x: Math.random() * gameState.mapSize.width,
                y: Math.random() * gameState.mapSize.height,
                width: 360,
                height: 360,
                hp: template.hp,
                maxHp: template.maxHp,
                speed: template.speed,
                attackRange: template.attackRange,
                sightRange: template.sightRange,
                type: template.type,
                image: template.image,
                latched: false,
                latchedTarget: null
            };

            if (type === 'clawWorm') {
                enemy.pullStrength = template.pullStrength;
                enemy.damagePerSecond = template.damagePerSecond;
            } else if (type === 'neonWorm') {
                enemy.attackDamage = template.attackDamage;
                enemy.shootCooldown = template.shootCooldown;
                enemy.lastShot = 0;
            }

            const dx = enemy.x - gameState.player.x;
            const dy = enemy.y - gameState.player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 400) {
                return createEnemy(type);
            }

            gameState.enemies.push(enemy);
        }

        function updateEnemyCount() {
            document.getElementById('enemyCount').textContent = gameState.enemies.length;
        }

        window.addEventListener('keydown', function(e) {
            gameState.keys[e.key.toLowerCase()] = true;
            if (e.key === ' ' && gameState.gameStarted) {
                e.preventDefault();
                attack();
            }
        });

        window.addEventListener('keyup', function(e) {
            gameState.keys[e.key.toLowerCase()] = false;
        });
        
        // Stop all movement when window loses focus
        window.addEventListener('blur', function() {
            gameState.keys = {};
        });

        canvas.addEventListener('mousemove', function(e) {
            const rect = canvas.getBoundingClientRect();
            gameState.mouse.x = e.clientX - rect.left;
            gameState.mouse.y = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', function() {
            gameState.mouse.down = true;
            attack();
        });

        canvas.addEventListener('mouseup', function() {
            gameState.mouse.down = false;
        });

        canvas.addEventListener('wheel', function(e) {
            e.preventDefault();
            const zoomSpeed = 0.05;
            const delta = e.deltaY > 0 ? -zoomSpeed : zoomSpeed;
            gameState.camera.zoom = Math.max(0.01, Math.min(2, gameState.camera.zoom + delta));
            document.getElementById('zoomLevel').textContent = Math.round(gameState.camera.zoom * 100);
        });
        
        // Mobile pinch-to-zoom
        let lastTouchDistance = 0;
        canvas.addEventListener('touchstart', function(e) {
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
            }
        });
        
        canvas.addEventListener('touchmove', function(e) {
            if (e.touches.length === 2) {
                e.preventDefault();
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (lastTouchDistance > 0) {
                    const delta = (distance - lastTouchDistance) * 0.01;
                    gameState.camera.zoom = Math.max(0.01, Math.min(2, gameState.camera.zoom + delta));
                    document.getElementById('zoomLevel').textContent = Math.round(gameState.camera.zoom * 100);
                }
                
                lastTouchDistance = distance;
            }
        });
        
        canvas.addEventListener('touchend', function() {
            lastTouchDistance = 0;
        });

        function attack() {
            if (!gameState.player || !gameState.gameStarted) return;
            
            const now = Date.now();
            if (now - gameState.player.lastAttack < gameState.player.attackCooldown) return;
            
            gameState.player.lastAttack = now;
            gameState.player.isAttacking = true;
            
            // Auto-lock on nearest enemy
            let targetEnemy = null;
            let closestDist = Infinity;
            
            gameState.enemies.forEach(function(enemy) {
                const dx = enemy.x - gameState.player.x;
                const dy = enemy.y - gameState.player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < closestDist && dist < gameState.player.attackRange) {
                    closestDist = dist;
                    targetEnemy = enemy;
                }
            });
            
            gameState.targetEnemy = targetEnemy;
            
            // If we found a target, aim at it, otherwise use mouse position
            if (targetEnemy) {
                gameState.player.attackAngle = Math.atan2(
                    targetEnemy.y - gameState.player.y,
                    targetEnemy.x - gameState.player.x
                );
            } else {
                const worldMouseX = gameState.mouse.x / gameState.camera.zoom + gameState.camera.x;
                const worldMouseY = gameState.mouse.y / gameState.camera.zoom + gameState.camera.y;
                gameState.player.attackAngle = Math.atan2(
                    worldMouseY - gameState.player.y,
                    worldMouseX - gameState.player.x
                );
            }

            if (gameState.player.attackType === 'ranged') {
                // Play attack sound
                playSound('playerAttack', gameState.selectedCharacter);
                
                gameState.projectiles.push({
                    x: gameState.player.x,
                    y: gameState.player.y,
                    vx: Math.cos(gameState.player.attackAngle) * 8,
                    vy: Math.sin(gameState.player.attackAngle) * 8,
                    damage: gameState.player.attackDamage,
                    color: gameState.player.attackColor,
                    radius: 8,
                    trail: []
                });
            } else {
                gameState.enemies.forEach(function(enemy) {
                    const dx = enemy.x - gameState.player.x;
                    const dy = enemy.y - gameState.player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);
                    const angleDiff = Math.abs(angle - gameState.player.attackAngle);
                    
                    if (dist < gameState.player.attackRange && angleDiff < Math.PI / 4) {
                        enemy.hp -= gameState.player.attackDamage;
                    }
                });
            }

            setTimeout(function() {
                if (gameState.player) gameState.player.isAttacking = false;
            }, 200);
        }

        function update() {
            if (!gameState.player || !gameState.gameStarted) return;

            // Apply mobile controls
            applyMobileControls();
            
            // Mobile auto-fire
            if (mobileFireActive) {
                attack();
            }

            let dx = 0;
            let dy = 0;

            if (gameState.keys['w'] || gameState.keys['arrowup']) dy -= 1;
            if (gameState.keys['s'] || gameState.keys['arrowdown']) dy += 1;
            if (gameState.keys['a'] || gameState.keys['arrowleft']) dx -= 1;
            if (gameState.keys['d'] || gameState.keys['arrowright']) dx += 1;

            if (dx !== 0 && dy !== 0) {
                dx *= 0.707;
                dy *= 0.707;
            }

            if (!gameState.player.latched) {
                gameState.player.x += dx * gameState.player.speed;
                gameState.player.y += dy * gameState.player.speed;

                gameState.player.x = Math.max(30, Math.min(gameState.mapSize.width - 30, gameState.player.x));
                gameState.player.y = Math.max(40, Math.min(gameState.mapSize.height - 40, gameState.player.y));
            }

            // Update player angle towards mouse (for aiming only, not rendering)
            const worldMouseX = gameState.mouse.x / gameState.camera.zoom + gameState.camera.x;
            const worldMouseY = gameState.mouse.y / gameState.camera.zoom + gameState.camera.y;
            gameState.player.angle = Math.atan2(
                worldMouseY - gameState.player.y,
                worldMouseX - gameState.player.x
            );

            gameState.camera.x = gameState.player.x - canvas.width / (2 * gameState.camera.zoom);
            gameState.camera.y = gameState.player.y - canvas.height / (2 * gameState.camera.zoom);

            const now = Date.now();
            gameState.player.latched = false;
            
            // Continuous auto-targeting - find nearest enemy
            let targetEnemy = null;
            let closestDist = Infinity;
            
            gameState.enemies.forEach(function(enemy) {
                const dx = enemy.x - gameState.player.x;
                const dy = enemy.y - gameState.player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < closestDist && dist < gameState.player.attackRange) {
                    closestDist = dist;
                    targetEnemy = enemy;
                }
            });
            
            gameState.targetEnemy = targetEnemy;

            gameState.enemies.forEach(function(enemy) {
                const dx = gameState.player.x - enemy.x;
                const dy = gameState.player.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < enemy.sightRange) {
                    if (enemy.type === 'clawWorm') {
                        if (dist < enemy.attackRange) {
                            const pullX = (dx / dist) * enemy.pullStrength * -1;
                            const pullY = (dy / dist) * enemy.pullStrength * -1;
                            gameState.player.x += pullX;
                            gameState.player.y += pullY;

                            // Damage player every second while in range
                            if (!enemy.lastDamageTime) {
                                enemy.lastDamageTime = now;
                                gameState.player.hp -= 1;
                                console.log('Claw worm damage! HP:', gameState.player.hp);
                                updateHealth();
                            } else if (now - enemy.lastDamageTime >= 1000) {
                                gameState.player.hp -= 1;
                                enemy.lastDamageTime = now;
                                console.log('Claw worm damage tick! HP:', gameState.player.hp);
                                updateHealth();
                            }

                            if (dist < 216) {
                                enemy.latched = true;
                                gameState.player.latched = true;
                            } else {
                                enemy.latched = false;
                            }
                        } else {
                            enemy.latched = false;
                            enemy.lastDamageTime = null;
                        }
                    } else if (enemy.type === 'neonWorm') {
                        if (dist < enemy.attackRange) {
                            if (now - enemy.lastShot > enemy.shootCooldown) {
                                const angle = Math.atan2(dy, dx);
                                
                                // Play enemy attack sound
                                playSound('enemyAttack');
                                
                                gameState.projectiles.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    vx: Math.cos(angle) * 4,
                                    vy: Math.sin(angle) * 4,
                                    damage: enemy.attackDamage,
                                    color: '#aa00ff',
                                    radius: 6,
                                    trail: [],
                                    isEnemy: true
                                });
                                enemy.lastShot = now;
                            }
                        }
                    } else if (enemy.type === 'gasWorm') {
                        // Gas Worm follows the player
                        if (dist > 300) {
                            const moveX = (dx / dist) * enemy.speed;
                            const moveY = (dy / dist) * enemy.speed;
                            enemy.x += moveX;
                            enemy.y += moveY;
                        }
                        
                        // Deal damage when close to player - increased range so it damages when approaching
                        if (dist < 400) {
                            if (!enemy.lastContactDamage) {
                                enemy.lastContactDamage = now;
                                gameState.player.hp -= 2;
                                console.log('Gas worm CONTACT damage! Distance:', Math.round(dist), 'HP:', gameState.player.hp);
                                updateHealth();
                            } else if (now - enemy.lastContactDamage >= 1000) {
                                gameState.player.hp -= 2;
                                enemy.lastContactDamage = now;
                                console.log('Gas worm CONTACT damage tick! Distance:', Math.round(dist), 'HP:', gameState.player.hp);
                                updateHealth();
                            }
                        } else {
                            enemy.lastContactDamage = null;
                        }
                        
                        // Shoot green gas bombs
                        if (dist < enemy.attackRange) {
                            if (now - enemy.lastShot > enemy.shootCooldown) {
                                const angle = Math.atan2(dy, dx);
                                
                                // Play enemy attack sound
                                playSound('enemyAttack');
                                
                                console.log('Gas worm shooting!');
                                
                                gameState.projectiles.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    vx: Math.cos(angle) * 5,
                                    vy: Math.sin(angle) * 5,
                                    damage: 2,
                                    color: '#00ff00',
                                    radius: 10,
                                    trail: [],
                                    isEnemy: true,
                                    isGas: true
                                });
                                enemy.lastShot = now;
                            }
                        }
                    }
                }
            });

            gameState.projectiles = gameState.projectiles.filter(function(proj) {
                proj.x += proj.vx;
                proj.y += proj.vy;

                proj.trail.push({ x: proj.x, y: proj.y });
                if (proj.trail.length > 10) proj.trail.shift();

                if (proj.x < 0 || proj.x > gameState.mapSize.width || 
                    proj.y < 0 || proj.y > gameState.mapSize.height) {
                    return false;
                }

                if (proj.isEnemy) {
                    const dx = proj.x - gameState.player.x;
                    const dy = proj.y - gameState.player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 216) {
                        gameState.player.hp -= proj.damage;
                        playSound('playerHit');
                        updateHealth();
                        
                        // Create gas cloud if it's a gas projectile
                        if (proj.isGas) {
                            gameState.gasClouds.push({
                                x: proj.x,
                                y: proj.y,
                                radius: 200,
                                damage: proj.damage,
                                createdAt: now,
                                duration: 20000,
                                lastDamage: 0
                            });
                            console.log('Gas cloud created at:', proj.x, proj.y);
                        }
                        
                        return false;
                    }
                    
                    // Create gas cloud if projectile travels too far
                    if (proj.isGas && (proj.x < 0 || proj.x > gameState.mapSize.width || 
                        proj.y < 0 || proj.y > gameState.mapSize.height)) {
                        gameState.gasClouds.push({
                            x: proj.x,
                            y: proj.y,
                            radius: 200,
                            damage: proj.damage,
                            createdAt: now,
                            duration: 20000,
                            lastDamage: 0
                        });
                        console.log('Gas cloud created at edge:', proj.x, proj.y);
                        return false;
                    }
                } else {
                    for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                        const enemy = gameState.enemies[i];
                        const dx = proj.x - enemy.x;
                        const dy = proj.y - enemy.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 180) {
                            enemy.hp -= proj.damage;
                            playSound('enemyHit');
                            return false;
                        }
                    }
                }

                return true;
            });

            gameState.enemies = gameState.enemies.filter(function(enemy) {
                return enemy.hp > 0;
            });
            updateEnemyCount();
            
            // Update gas clouds
            gameState.gasClouds = gameState.gasClouds.filter(function(cloud) {
                // Check if cloud has expired
                if (now - cloud.createdAt > cloud.duration) {
                    return false;
                }
                
                // Check if player is in gas cloud
                const dx = gameState.player.x - cloud.x;
                const dy = gameState.player.y - cloud.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < cloud.radius) {
                    // Initialize lastDamage if not set
                    if (!cloud.lastDamage) {
                        cloud.lastDamage = now - 1000; // Set to allow immediate damage
                    }
                    
                    // Damage player every second
                    if (now - cloud.lastDamage >= 1000) {
                        gameState.player.hp -= 2;
                        cloud.lastDamage = now;
                        console.log('Gas cloud damage! HP:', gameState.player.hp, 'Cloud at:', cloud.x, cloud.y);
                        updateHealth();
                    }
                }
                
                return true;
            });

            if (gameState.player.hp <= 0) {
                gameState.lives--;
                document.getElementById('livesDisplay').textContent = gameState.lives;
                
                if (gameState.lives > 0) {
                    // Respawn player
                    gameState.player.hp = gameState.player.maxHp;
                    gameState.player.x = gameState.mapSize.width / 2;
                    gameState.player.y = gameState.mapSize.height / 2;
                    gameState.gasClouds = []; // Clear gas clouds on respawn
                    updateHealth();
                    console.log('Life lost! Lives remaining:', gameState.lives);
                } else {
                    gameOver();
                }
            } else if (gameState.enemies.length === 0) {
                levelComplete();
            }

            saveGame();
        }

        function updateHealth() {
            const healthPercent = Math.max(0, (gameState.player.hp / gameState.player.maxHp) * 100);
            document.getElementById('healthFill').style.width = healthPercent + '%';
            document.getElementById('healthText').textContent = 
                Math.max(0, Math.round(gameState.player.hp)) + ' / ' + gameState.player.maxHp;
        }

        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.scale(gameState.camera.zoom, gameState.camera.zoom);
            ctx.translate(-gameState.camera.x, -gameState.camera.y);

            const bgImg = gameState.images['https://github.com/TitanBusinessPros/FAR-Earth/raw/main/BG-Tile.png'];
            if (bgImg) {
                ctx.drawImage(bgImg, 0, 0, gameState.mapSize.width, gameState.mapSize.height);
            }

            if (gameState.player) {
                ctx.beginPath();
                ctx.arc(gameState.player.x, gameState.player.y, 500, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.save();
                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, gameState.mapSize.width, gameState.mapSize.height);
                ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                ctx.arc(gameState.player.x, gameState.player.y, 500, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            gameState.enemies.forEach(function(enemy) {
                const img = gameState.images[enemy.image];
                if (img) {
                    const dx = gameState.player.x - enemy.x;
                    const dy = gameState.player.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 500) {
                        ctx.save();
                        ctx.translate(enemy.x, enemy.y);
                        
                        // Draw lock-on indicator if this is the target
                        if (gameState.targetEnemy === enemy) {
                            ctx.strokeStyle = '#ffff00';
                            ctx.lineWidth = 8;
                            ctx.setLineDash([20, 10]);
                            ctx.beginPath();
                            ctx.arc(0, 0, enemy.width / 2 + 40, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }
                        
                        // Add glow effect for enemies
                        ctx.shadowBlur = 50;
                        if (enemy.type === 'clawWorm') {
                            ctx.shadowColor = '#ff0000';
                        } else if (enemy.type === 'gasWorm') {
                            ctx.shadowColor = '#00ff00';
                            
                            // Add vibration effect
                            const vibrateX = (Math.random() - 0.5) * 10;
                            const vibrateY = (Math.random() - 0.5) * 10;
                            ctx.translate(vibrateX, vibrateY);
                        } else {
                            ctx.shadowColor = '#aa00ff';
                        }
                        
                        ctx.drawImage(img, -enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
                        ctx.shadowBlur = 0;
                        
                        const hpPercent = enemy.hp / enemy.maxHp;
                        ctx.fillStyle = '#333';
                        ctx.fillRect(-180, -enemy.height / 2 - 36, 360, 24);
                        ctx.fillStyle = hpPercent > 0.5 ? '#00ff00' : (hpPercent > 0.25 ? '#ffff00' : '#ff0000');
                        ctx.fillRect(-180, -enemy.height / 2 - 36, 360 * hpPercent, 24);
                        
                        if (enemy.type === 'clawWorm' && dist < enemy.attackRange) {
                            ctx.beginPath();
                            ctx.arc(0, 0, enemy.attackRange, 0, Math.PI * 2);
                            ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                            
                            if (enemy.latched) {
                                ctx.strokeStyle = 'rgba(255, 0, 0, 0.6)';
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.moveTo(0, 0);
                                ctx.lineTo(gameState.player.x - enemy.x, gameState.player.y - enemy.y);
                                ctx.stroke();
                            }
                        }
                        
                        ctx.restore();
                    }
                }
            });

            gameState.projectiles.forEach(function(proj) {
                proj.trail.forEach(function(point, i) {
                    const alpha = (i + 1) / proj.trail.length;
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, proj.radius * alpha, 0, Math.PI * 2);
                    ctx.fillStyle = proj.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                    ctx.fill();
                });

                ctx.beginPath();
                ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
                ctx.fillStyle = proj.color;
                ctx.fill();
                ctx.shadowBlur = 20;
                ctx.shadowColor = proj.color;
                ctx.fill();
                ctx.shadowBlur = 0;
            });
            
            // Draw gas clouds
            gameState.gasClouds.forEach(function(cloud) {
                const age = Date.now() - cloud.createdAt;
                const lifePercent = 1 - (age / cloud.duration);
                
                // Pulsating effect
                const pulseRadius = cloud.radius + Math.sin(age / 200) * 10;
                
                // Draw outer glow
                ctx.beginPath();
                ctx.arc(cloud.x, cloud.y, pulseRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 255, 0, ' + (0.2 * lifePercent) + ')';
                ctx.shadowBlur = 40;
                ctx.shadowColor = '#00ff00';
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Draw inner cloud
                ctx.beginPath();
                ctx.arc(cloud.x, cloud.y, pulseRadius * 0.7, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 255, 0, ' + (0.4 * lifePercent) + ')';
                ctx.fill();
            });

            if (gameState.player) {
                const img = gameState.images[gameState.player.image];
                if (img) {
                    ctx.save();
                    ctx.translate(gameState.player.x, gameState.player.y);
                    // Character stays upright - no rotation
                    
                    // Add glow effect based on character
                    ctx.shadowBlur = 60;
                    ctx.shadowColor = gameState.player.attackColor;
                    
                    ctx.drawImage(img, -gameState.player.width / 2, -gameState.player.height / 2, 
                                  gameState.player.width, gameState.player.height);
                    ctx.shadowBlur = 0;
                    ctx.restore();

                    if (gameState.player.isAttacking) {
                        ctx.save();
                        ctx.translate(gameState.player.x, gameState.player.y);
                        ctx.rotate(gameState.player.attackAngle);
                        
                        if (gameState.player.attackType === 'melee') {
                            ctx.strokeStyle = gameState.player.attackColor;
                            ctx.lineWidth = 5;
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = gameState.player.attackColor;
                            ctx.beginPath();
                            ctx.arc(0, 0, gameState.player.attackRange, -Math.PI / 4, Math.PI / 4);
                            ctx.stroke();
                            ctx.shadowBlur = 0;
                        }
                        
                        ctx.restore();
                    }
                }
            }

            ctx.restore();
        }

        function gameLoop() {
            if (!gameState.gameStarted) return;
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        function levelComplete() {
            gameState.gameStarted = false;
            document.getElementById('levelComplete').style.display = 'block';
        }

        function nextLevel() {
            gameState.currentLevel++;
            document.getElementById('levelDisplay').textContent = gameState.currentLevel;
            document.getElementById('levelComplete').style.display = 'none';
            
            if (gameState.currentLevel === 2) {
                // Redirect to Stage 2
                window.location.href = 'FE-Stage-2.html';
            } else if (gameState.currentLevel <= 20) {
                gameState.player.hp = gameState.player.maxHp;
                gameState.lives = 3; // Reset lives for new level
                document.getElementById('livesDisplay').textContent = gameState.lives;
                updateHealth();
                initializeLevel();
                gameState.gameStarted = true;
                gameLoop();
            } else {
                alert('Congratulations! You have completed all 20 levels of FAR-Earth!');
                restartGame();
            }
        }

        function gameOver() {
            gameState.gameStarted = false;
            document.getElementById('gameOver').style.display = 'block';
        }

        function restartGame() {
            localStorage.removeItem('farEarthSave');
            location.reload();
        }

        function saveGame() {
            const saveData = {
                level: gameState.currentLevel,
                character: gameState.selectedCharacter,
                playerHp: gameState.player ? gameState.player.hp : 100
            };
            localStorage.setItem('farEarthSave', JSON.stringify(saveData));
        }

        function loadGame() {
            const saved = localStorage.getItem('farEarthSave');
            if (saved) {
                gameState.saveData = JSON.parse(saved);
                if (gameState.saveData.character === gameState.selectedCharacter) {
                    gameState.currentLevel = gameState.saveData.level;
                    document.getElementById('levelDisplay').textContent = gameState.currentLevel;
                }
            }
        }

        window.addEventListener('resize', function() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        preloadImages();
        
        // Detect mobile and show mobile controls
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
        if (isMobile) {
            document.getElementById('mobileControls').style.display = 'block';
            document.getElementById('controls').style.display = 'none';
        }
        
        // Mobile joystick
        let joystickActive = false;
        let joystickDirection = { x: 0, y: 0 };
        
        const joystickContainer = document.getElementById('joystickContainer');
        const joystickStick = document.getElementById('joystickStick');
        
        joystickContainer.addEventListener('touchstart', function(e) {
            e.preventDefault();
            joystickActive = true;
            updateJoystick(e.touches[0]);
        });
        
        joystickContainer.addEventListener('touchmove', function(e) {
            e.preventDefault();
            if (joystickActive) updateJoystick(e.touches[0]);
        });
        
        joystickContainer.addEventListener('touchend', function(e) {
            e.preventDefault();
            joystickActive = false;
            joystickDirection = { x: 0, y: 0 };
            joystickStick.style.left = '45px';
            joystickStick.style.top = '45px';
        });
        
        function updateJoystick(touch) {
            const rect = joystickContainer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            let deltaX = touch.clientX - centerX;
            let deltaY = touch.clientY - centerY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = 45;
            
            if (distance > maxDistance) {
                deltaX = (deltaX / distance) * maxDistance;
                deltaY = (deltaY / distance) * maxDistance;
            }
            
            joystickStick.style.left = (45 + deltaX) + 'px';
            joystickStick.style.top = (45 + deltaY) + 'px';
            
            joystickDirection.x = deltaX / maxDistance;
            joystickDirection.y = deltaY / maxDistance;
        }
        
        // Apply joystick movement in game loop
        function applyMobileControls() {
            if (joystickActive && gameState.player) {
                gameState.player.x += joystickDirection.x * gameState.player.speed;
                gameState.player.y += joystickDirection.y * gameState.player.speed;
                gameState.player.x = Math.max(50, Math.min(gameState.mapSize.width - 50, gameState.player.x));
                gameState.player.y = Math.max(50, Math.min(gameState.mapSize.height - 50, gameState.player.y));
            }
        }
        
        // Fire button
        let mobileFireActive = false;
        const fireBtn = document.getElementById('fireBtn');
        fireBtn.addEventListener('touchstart', function(e) {
            e.preventDefault();
            mobileFireActive = true;
        });
        fireBtn.addEventListener('touchend', function(e) {
            e.preventDefault();
            mobileFireActive = false;
        });
        
        // Start background music
        const bgMusic = document.getElementById('bgMusic');
        bgMusic.volume = 0.5;
        
        // Auto-play music on any user interaction
        document.addEventListener('click', function() {
            bgMusic.play().catch(function(e) {
                console.log('Audio autoplay prevented:', e);
            });
        }, { once: true });
        
        document.querySelectorAll('.characterCard').forEach(function(card) {
            card.addEventListener('click', function() {
                const charIndex = parseInt(this.getAttribute('data-character'));
                selectCharacter(charIndex);
            });
        });
        
        document.getElementById('nextLevelBtn').addEventListener('click', nextLevel);
        document.getElementById('restartBtn').addEventListener('click', restartGame);
        
        // Pause button functionality
        document.getElementById('pauseBtn').addEventListener('click', function() {
            gameState.gameStarted = false;
            document.getElementById('pauseMenu').style.display = 'block';
        });
        
        document.getElementById('resumeBtn').addEventListener('click', function() {
            document.getElementById('pauseMenu').style.display = 'none';
            gameState.gameStarted = true;
            gameLoop();
        });
        
        document.getElementById('quitBtn').addEventListener('click', function() {
            location.reload();
        });
        
        // Show pause button when game starts
        function showPauseButton() {
            document.getElementById('pauseBtn').style.display = 'block';
        }
    </script>
</body>
</html>
